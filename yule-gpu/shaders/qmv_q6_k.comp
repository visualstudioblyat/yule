#version 450

// Q6_K: 210 bytes/super-block = 256 weights.
// Layout: [ql: 128B] [qh: 64B] [scales: 16B int8] [d: f16 (2B)]
// 6-bit symmetric quantization, subtract 32 bias.
// Two halves of 128 weights each:
//   half 0: ql[0..64], qh[0..32]  → weights[0..127]
//   half 1: ql[64..128], qh[32..64] → weights[128..255]
// Within each half, 4 groups of 32 weights from ql low/high nibbles + qh 2-bit pairs.

layout(local_size_x = 256) in;

layout(set = 0, binding = 0) buffer Weights { uint weight_data[]; };
layout(set = 0, binding = 1) buffer Input { float input_data[]; };
layout(set = 0, binding = 2) buffer Out { float out_data[]; };

layout(push_constant) uniform Params {
    uint n_rows;
    uint n_cols;
    uint blocks_per_row;
};

shared float partial_sums[256];

float unpack_f16(uint bits) {
    uint sign = (bits >> 15) & 1u;
    uint exp  = (bits >> 10) & 0x1Fu;
    uint mant = bits & 0x3FFu;
    if (exp == 0u) {
        float val = ldexp(float(mant), -24);
        return sign == 1u ? -val : val;
    }
    if (exp == 31u) return sign == 1u ? -1.0/0.0 : 1.0/0.0;
    float val = ldexp(float(mant | 0x400u), int(exp) - 25);
    return sign == 1u ? -val : val;
}

uint read_byte(uint byte_addr) {
    uint word = weight_data[byte_addr / 4u];
    return (word >> ((byte_addr % 4u) * 8u)) & 0xFFu;
}

uint read_u16(uint byte_addr) {
    return read_byte(byte_addr) | (read_byte(byte_addr + 1u) << 8u);
}

// Read int8 as signed (-128..127)
int read_i8(uint byte_addr) {
    uint b = read_byte(byte_addr);
    return int(b) - (int(b & 0x80u) << 1);  // sign extend
}

void main() {
    uint row = gl_WorkGroupID.x;
    if (row >= n_rows) return;
    uint tid = gl_LocalInvocationID.x;

    uint row_byte_offset = row * blocks_per_row * 210u;
    float sum = 0.0;

    for (uint block = tid; block < blocks_per_row; block += gl_WorkGroupSize.x) {
        uint boff = row_byte_offset + block * 210u;

        // d is at offset 208 within the block
        float d = unpack_f16(read_u16(boff + 208u));

        uint col_base = block * 256u;

        // Process two halves of 128 weights each
        for (uint h = 0u; h < 2u; h++) {
            uint ql_off = boff + h * 64u;         // 64 bytes of ql per half
            uint qh_off = boff + 128u + h * 32u;  // 32 bytes of qh per half
            uint sc_off = boff + 192u;             // scales base
            uint sc_base = h * 8u;
            uint out_base = col_base + h * 128u;

            for (uint l = 0u; l < 32u; l++) {
                uint is_idx = l / 16u;  // sub-block index within half

                uint ql_lo = read_byte(ql_off + l);
                uint ql_hi = read_byte(ql_off + l + 32u);
                uint qh_val = read_byte(qh_off + l);

                // 4 groups of weights from this position
                int q1 = int((ql_lo & 0xFu) | (((qh_val >> 0u) & 0x3u) << 4u)) - 32;
                int q2 = int((ql_hi & 0xFu) | (((qh_val >> 2u) & 0x3u) << 4u)) - 32;
                int q3 = int((ql_lo >> 4u) | (((qh_val >> 4u) & 0x3u) << 4u)) - 32;
                int q4 = int((ql_hi >> 4u) | (((qh_val >> 6u) & 0x3u) << 4u)) - 32;

                // Read int8 scales
                float s1 = float(read_i8(sc_off + sc_base + is_idx + 0u));
                float s2 = float(read_i8(sc_off + sc_base + is_idx + 2u));
                float s3 = float(read_i8(sc_off + sc_base + is_idx + 4u));
                float s4 = float(read_i8(sc_off + sc_base + is_idx + 6u));

                uint c1 = out_base + l;
                uint c2 = out_base + l + 32u;
                uint c3 = out_base + l + 64u;
                uint c4 = out_base + l + 96u;

                if (c1 < n_cols) sum += d * s1 * float(q1) * input_data[c1];
                if (c2 < n_cols) sum += d * s2 * float(q2) * input_data[c2];
                if (c3 < n_cols) sum += d * s3 * float(q3) * input_data[c3];
                if (c4 < n_cols) sum += d * s4 * float(q4) * input_data[c4];
            }
        }
    }

    partial_sums[tid] = sum;
    barrier();
    for (uint s = gl_WorkGroupSize.x / 2; s > 0; s >>= 1) {
        if (tid < s) partial_sums[tid] += partial_sums[tid + s];
        barrier();
    }
    if (tid == 0) out_data[row] = partial_sums[0];
}
